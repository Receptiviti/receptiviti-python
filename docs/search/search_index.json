{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python package to process text with the Receptiviti API.</p>"},{"location":"#installation","title":"Installation","text":"<p>If needed, download Python from python.org, then install the package with pip:</p> <pre><code>pip install git+https://github.com/miserman/receptiviti-py.git\n</code></pre> <p>And load the package in a python console:</p> <pre><code>import receptiviti\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<pre><code># score a single text\nsingle = receptiviti.request(\"a text to score\")\n# score multiple texts, and write results to a file\nmulti = receptiviti.request([\"first text to score\", \"second text\"], \"filename.csv\")\n# score texts in separate files\n## defaults to look for .txt files\nfile_results = receptiviti.request(\"./path/to/txt_folder\")\n## could be .csv\nfile_results = receptiviti.request(\n\"./path/to/csv_folder\",\ntext_column = \"text\", file_type = \"csv\"\n)\n# score texts in a single file\nresults = receptiviti.request(\"./path/to/file.csv\", text_column = \"text\")\n</code></pre>"},{"location":"#api-access","title":"API Access","text":"<p>To access the API, you will need to load your key and secret, as found on your dashboard.</p> <p>You can enter these as arguments in each function call, but by default they will be looked for in these environment variables:</p> <pre><code>RECEPTIVITI_KEY=\"32lettersandnumbers\"\nRECEPTIVITI_SECRET=\"56LettersAndNumbers\"\n</code></pre> <p>You can store these in a <code>.env</code> (in the current directory or <code>~/Documents</code>) file permanently:</p> <pre><code># use the `dotenv` argument\nreceptiviti.status(dotenv=True)\n# or load variables in beforehand\nreceptiviti.readin_env()\n</code></pre> <p>Or set them temporarily:</p> <pre><code>import os\nos.environ[\"RECEPTIVITI_KEY\"]=\"32lettersandnumbers\"\nos.environ[\"RECEPTIVITI_SECRET\"]=\"56LettersAndNumbers\"\n</code></pre>"},{"location":"functions/readin_env/","title":"Readin env","text":"<p>Read in a environment variables.</p>"},{"location":"functions/readin_env/#receptiviti.readin_env.readin_env","title":"<code>readin_env(path='.', name='.env', overwrite=False)</code>","text":"<p>Set environment variables from a .env file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a .env file, or to a directory containing such a file. By default, this will fall back on <code>~/Documents</code>.</p> <code>'.'</code> <code>name</code> <code>str</code> <p>Name of the file, when <code>path</code> points to a directory. By default, this will fall back on <code>.Renviron</code>.</p> <code>'.env'</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, overwrites existing environment variables with the same name as those in the .env file.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>If a file is found, it will add contents to <code>os.environ</code>.</p> Source code in <code>src\\receptiviti\\readin_env.py</code> <pre><code>def readin_env(path=\".\", name=\".env\", overwrite=False) -&gt; None:\n\"\"\"\n    Set environment variables from a .env file.\n    Args:\n      path (str): Path to a .env file, or to a directory containing such a file.\n        By default, this will fall back on `~/Documents`.\n      name (str): Name of the file, when `path` points to a directory.\n        By default, this will fall back on `.Renviron`.\n      overwrite (bool): If `True`, overwrites existing environment variables with\n        the same name as those in the .env file.\n    Returns:\n      If a file is found, it will add contents to `os.environ`.\n    \"\"\"\npath = os.path.expanduser(path)\nenvpath = path if os.path.isfile(path) else path + \"/\" + name\nif os.path.isfile(envpath):\nql = re.compile(\"^['\\\"]|['\\\"\\\\s]+$\")\nwith open(envpath, encoding=\"utf-8\") as file:\nfor line in file:\nentry = line.split(\"=\", 1)\nif len(entry) == 2:\nif overwrite or os.getenv(entry[0]) is None:\nos.environ[entry[0]] = ql.sub(\"\", entry[1])\nelif name != \".Renviron\":\nreadin_env(path, \".Renviron\", overwrite)\nelse:\nif path != os.path.expanduser(\"~/Documents\"):\nreadin_env(\"~/Documents\", name, overwrite)\nreturn\n</code></pre>"},{"location":"functions/request/","title":"Request","text":"<p>Make requests to the API.</p>"},{"location":"functions/request/#receptiviti.request.request","title":"<code>request(text, output=None, ids=None, text_column=None, id_column=None, file_type='txt', return_text=False, api_args=None, frameworks=None, framework_prefix=None, bundle_size=1000, bundle_byte_limit=7500000.0, collapse_lines=False, retry_limit=50, clear_cache=False, request_cache=True, parallel=True, verbose=False, progress_bar=True, overwrite=False, make_request=True, text_as_paths=False, dotenv=True, cache=os.getenv('RECEPTIVITI_CACHE', ''), cache_overwrite=False, cache_format=os.getenv('RECEPTIVITI_CACHE_FORMAT', 'parquet'), key=os.getenv('RECEPTIVITI_KEY', ''), secret=os.getenv('RECEPTIVITI_SECRET', ''), url=os.getenv('RECEPTIVITI_URL', ''), version=os.getenv('RECEPTIVITI_VERSION', ''), endpoint=os.getenv('RECEPTIVITI_ENDPOINT', ''))</code>","text":"<p>Send texts to be scored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | list | pandas.DataFrame</code> <p>Text to be processed.</p> required <code>output</code> <code>str</code> <p>Path to a file to write results to.</p> <code>None</code> <code>ids</code> <code>str | list</code> <p>Vector of IDs for each <code>text</code>, or a column name in <code>text</code> containing IDs.</p> <code>None</code> <code>text_column</code> <code>str</code> <p>Column name in <code>text</code> containing text.</p> <code>None</code> <code>id_column</code> <code>str</code> <p>Column name in <code>text</code> containing IDs.</p> <code>None</code> <code>file_type</code> <code>str</code> <p>Extension of the file(s) to be read in from a directory (<code>txt</code> or <code>csv</code>).</p> <code>'txt'</code> <code>return_text</code> <code>bool</code> <p>If <code>True</code>, will include a <code>text</code> column in the output with the original text.</p> <code>False</code> <code>api_args</code> <code>dict</code> <p>Additional arguments to include in the request.</p> <code>None</code> <code>frameworks</code> <code>str | list</code> <p>One or more names of frameworks to return.</p> <code>None</code> <code>framework_prefix</code> <code>bool</code> <p>If <code>False</code>, will drop framework prefix from column names. If one framework is selected, will default to <code>False</code>.</p> <code>None</code> <code>bundle_size</code> <code>int</code> <p>Maximum number of texts per bundle.</p> <code>1000</code> <code>bundle_byte_limit</code> <code>float</code> <p>Maximum byte size of each bundle.</p> <code>7500000.0</code> <code>collapse_lines</code> <code>bool</code> <p>If <code>True</code>, will treat files as containing single texts, and collapse multiple lines.</p> <code>False</code> <code>retry_limit</code> <code>int</code> <p>Number of times to retry a failed request.</p> <code>50</code> <code>clear_cache</code> <code>bool</code> <p>If <code>True</code>, will delete the <code>cache</code> before processing.</p> <code>False</code> <code>request_cache</code> <code>bool</code> <p>If <code>False</code>, will not temporarily save raw requests for reuse within a day.</p> <code>True</code> <code>parallel</code> <code>bool</code> <p>If <code>False</code>, will always process bundles on a single CPU core.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, will print status messages and preserve the progress bar.</p> <code>False</code> <code>progress_bar</code> <code>bool</code> <p>If <code>False</code>, will not display a progress bar.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, will overwrite an existing <code>output</code> file.</p> <code>False</code> <code>text_as_paths</code> <code>bool</code> <p>If <code>True</code>, will explicitly mark <code>text</code> as a list of file paths. Otherwise, this will be detected.</p> <code>False</code> <code>dotenv</code> <code>bool | str</code> <p>Path to a .env file to read environment variables from. By default, will for a file in the current directory or <code>~/Documents</code>. Passed to <code>readin_env</code> as <code>path</code>.</p> <code>True</code> <code>cache</code> <code>bool | str</code> <p>Path to a cache directory, <code>True</code> or <code>\"\"</code> to use the default directory, or <code>False</code> to not use a cache.</p> <code>os.getenv('RECEPTIVITI_CACHE', '')</code> <code>cache_overwrite</code> <code>bool</code> <p>If <code>True</code>, will not check the cache for previously cached texts, but will store results in the cache (unlike <code>cache = False</code>).</p> <code>False</code> <code>cache_format</code> <code>str</code> <p>File format of the cache, of available Arrow formats.</p> <code>os.getenv('RECEPTIVITI_CACHE_FORMAT', 'parquet')</code> <code>key</code> <code>str</code> <p>Your API key.</p> <code>os.getenv('RECEPTIVITI_KEY', '')</code> <code>secret</code> <code>str</code> <p>Your API secret.</p> <code>os.getenv('RECEPTIVITI_SECRET', '')</code> <code>url</code> <code>str</code> <p>The URL of the API; defaults to <code>https://api.receptiviti.com</code>.</p> <code>os.getenv('RECEPTIVITI_URL', '')</code> <code>version</code> <code>str</code> <p>Version of the API; defaults to <code>v1</code>.</p> <code>os.getenv('RECEPTIVITI_VERSION', '')</code> <code>endpoint</code> <code>str</code> <p>Endpoint of the API; defaults to <code>framework</code>.</p> <code>os.getenv('RECEPTIVITI_ENDPOINT', '')</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>Scores associated with each input text.</p> Source code in <code>src\\receptiviti\\request.py</code> <pre><code>def request(\ntext: Union[str, list, pandas.DataFrame],\noutput: Union[str, None] = None,\nids: Union[str, List[Union[str, int]], None] = None,\ntext_column: Union[str, None] = None,\nid_column: Union[str, None] = None,\nfile_type: str = \"txt\",\nreturn_text=False,\napi_args: Union[dict, None] = None,\nframeworks: Union[str, List[str], None] = None,\nframework_prefix: Union[bool, None] = None,\nbundle_size=1000,\nbundle_byte_limit=75e5,\ncollapse_lines=False,\nretry_limit=50,\nclear_cache=False,\nrequest_cache=True,\nparallel=True,\nverbose=False,\nprogress_bar=True,\noverwrite=False,\nmake_request=True,\ntext_as_paths=False,\ndotenv: Union[bool, str] = True,\ncache=os.getenv(\"RECEPTIVITI_CACHE\", \"\"),\ncache_overwrite=False,\ncache_format=os.getenv(\"RECEPTIVITI_CACHE_FORMAT\", \"parquet\"),\nkey=os.getenv(\"RECEPTIVITI_KEY\", \"\"),\nsecret=os.getenv(\"RECEPTIVITI_SECRET\", \"\"),\nurl=os.getenv(\"RECEPTIVITI_URL\", \"\"),\nversion=os.getenv(\"RECEPTIVITI_VERSION\", \"\"),\nendpoint=os.getenv(\"RECEPTIVITI_ENDPOINT\", \"\"),\n) -&gt; pandas.DataFrame:\n\"\"\"\n    Send texts to be scored by the API.\n    Args:\n      text (str | list | pandas.DataFrame): Text to be processed.\n      output (str): Path to a file to write results to.\n      ids (str | list): Vector of IDs for each `text`, or a column name in `text` containing IDs.\n      text_column (str): Column name in `text` containing text.\n      id_column (str): Column name in `text` containing IDs.\n      file_type (str): Extension of the file(s) to be read in from a directory (`txt` or `csv`).\n      return_text (bool): If `True`, will include a `text` column in the output with the\n        original text.\n      api_args (dict): Additional arguments to include in the request.\n      frameworks (str | list): One or more names of frameworks to return.\n      framework_prefix (bool): If `False`, will drop framework prefix from column names.\n        If one framework is selected, will default to `False`.\n      bundle_size (int): Maximum number of texts per bundle.\n      bundle_byte_limit (float): Maximum byte size of each bundle.\n      collapse_lines (bool): If `True`, will treat files as containing single texts, and\n        collapse multiple lines.\n      retry_limit (int): Number of times to retry a failed request.\n      clear_cache (bool): If `True`, will delete the `cache` before processing.\n      request_cache (bool): If `False`, will not temporarily save raw requests for reuse within a day.\n      parallel (bool): If `False`, will always process bundles on a single CPU core.\n      verbose (bool): If `True`, will print status messages and preserve the progress bar.\n      progress_bar (bool): If `False`, will not display a progress bar.\n      overwrite (bool): If `True`, will overwrite an existing `output` file.\n      text_as_paths (bool): If `True`, will explicitly mark `text` as a list of file paths.\n        Otherwise, this will be detected.\n      dotenv (bool | str): Path to a .env file to read environment variables from. By default,\n        will for a file in the current directory or `~/Documents`. Passed to `readin_env` as `path`.\n      cache (bool | str): Path to a cache directory, `True` or `\"\"` to use the default directory, or `False`\n        to not use a cache.\n      cache_overwrite (bool): If `True`, will not check the cache for previously cached texts, but will\n        store results in the cache (unlike `cache = False`).\n      cache_format (str): File format of the cache, of available Arrow formats.\n      key (str): Your API key.\n      secret (str): Your API secret.\n      url (str): The URL of the API; defaults to `https://api.receptiviti.com`.\n      version (str): Version of the API; defaults to `v1`.\n      endpoint (str): Endpoint of the API; defaults to `framework`.\n    Returns:\n      Scores associated with each input text.\n    \"\"\"\nif output is not None and os.path.isfile(output) and not overwrite:\nraise RuntimeError(\"`output` file already exists; use `overwrite=True` to overwrite it\")\nstart_time = perf_counter()\n# resolve credentials and check status\nif dotenv:\nreadin_env(\".\" if isinstance(dotenv, bool) else dotenv)\nif url == \"\":\nurl = os.getenv(\"RECEPTIVITI_URL\", \"https://api.receptiviti.com\")\nurl = (\"https://\" if re.match(\"http\", url, re.I) is None else \"\") + re.sub(\n\"/[Vv]\\\\d(?:/.*)?$|/+$\", \"\", url\n)\nif key == \"\":\nkey = os.getenv(\"RECEPTIVITI_KEY\", \"\")\nif secret == \"\":\nsecret = os.getenv(\"RECEPTIVITI_SECRET\", \"\")\nif version == \"\":\nversion = os.getenv(\"RECEPTIVITI_VERSION\", \"v1\")\nif endpoint == \"\":\nendpoint = os.getenv(\"RECEPTIVITI_ENDPOINT\", \"framework\")\napi_status = status(url, key, secret, dotenv, verbose=False)\nif api_status.status_code != 200:\nraise RuntimeError(f\"API status failed: {api_status.status_code}\")\n# resolve text and ids\ndef readin(\npaths: list[str],\ntext_cols=text_column,\nid_cols=id_column,\ncollapse=collapse_lines,\n) -&gt; list:\nsel = []\nif text_cols is not None:\nsel.append(text_cols)\nif id_cols is not None:\nsel.append(id_cols)\ntext = []\nif os.path.splitext(paths[0])[1] == \".txt\" and len(sel) == 0:\nfor file in paths:\nwith open(file, encoding=\"utf-8\") as texts:\nlines = [line.rstrip() for line in texts]\nif collapse:\ntext.append(\" \".join(lines))\nelse:\ntext += lines\nelse:\ntext = pandas.concat([pandas.read_csv(file, usecols=sel) for file in paths])\nreturn text\nif isinstance(text, str):\nif os.path.isfile(text):\nif verbose:\nprint(f\"reading in texts from a file ({perf_counter() - start_time:.4f})\")\ntext = readin([text])\ntext_as_paths = False\nelif os.path.isdir(text):\ntext = glob(f\"{text}/*{file_type}\")\ntext_as_paths = True\nif isinstance(text, pandas.DataFrame):\nif id_column is not None:\nif id_column in text:\nids = text[id_column].to_list()\nelse:\nraise IndexError(f\"`id_column` ({id_column}) is not in `text`\")\nif text_column is not None:\nif text_column in text:\ntext = text[text_column].to_list()\nelse:\nraise IndexError(f\"`text_column` ({text_column}) is not in `text`\")\nelse:\nraise RuntimeError(\"`text` is a DataFrame, but no `text_column` is specified\")\nif isinstance(text, str):\ntext = [text]\ntext_is_path = all((len(t) &lt; 500 and os.path.isfile(t) for t in text))\nif text_as_paths and not text_is_path:\nraise RuntimeError(\"`text` treated as a list of files, but not all of the entries exist\")\nif text_is_path and not collapse_lines:\ntext = readin(text)\ntext_is_path = False\nid_specified = ids is not None\nif not id_specified:\nids = numpy.arange(1, len(text) + 1)\nelif len(ids) != len(text):\nraise RuntimeError(\"`ids` is not the same length as `text`\")\noriginal_ids = set(ids)\nif len(ids) != len(original_ids):\nraise RuntimeError(\"`ids` contains duplicates\")\n# prepare bundles\nif verbose:\nprint(f\"preparing text ({perf_counter() - start_time:.4f})\")\ndata = pandas.DataFrame({\"text\": text, \"id\": ids})\nn_original = data.shape[0]\ngroups = data[~(data.duplicated(subset=[\"text\"]) | (data[\"text\"] == \"\") | data[\"text\"].isna())]\nn_texts = groups.shape[0]\nif not n_texts:\nraise RuntimeError(\"no valid texts to process\")\nbundle_size = max(1, bundle_size)\nn_bundles = math.ceil(n_texts / min(1000, bundle_size))\ngroups = groups.groupby(\nnumpy.sort(numpy.tile(numpy.arange(n_bundles) + 1, bundle_size))[:n_texts], group_keys=False\n)\nbundles = []\ngetsize = sys.getsizeof if not text_is_path else lambda f: os.stat(f).st_size\nfor _, group in groups:\nif getsize(group) &gt; bundle_byte_limit:\nstart = current = end = 0\nfor txt in group[\"text\"]:\nsize = getsize(txt)\nif size &gt; bundle_byte_limit:\nraise RuntimeError(\n\"one of your texts is over the bundle size\"\n+ f\" limit ({bundle_byte_limit / 1e6} MB)\"\n)\nif (current + size) &gt; bundle_byte_limit:\nbundles.append(group[start:end])\nstart = end = end + 1\ncurrent = size\nelse:\nend += 1\ncurrent += size\nbundles.append(group[start:])\nelse:\nbundles.append(group)\nif verbose:\nprint(\nf\"prepared {n_texts} unique text{'s' if n_texts &gt; 1 else ''} in \"\nf\"{len(bundles)} {'bundles' if len(bundles) &gt; 1 else 'bundle'}\",\nf\"({perf_counter() - start_time:.4f})\",\n)\n# process bundles\nif isinstance(cache, str):\nif cache == \"\":\ncache = CACHE\nif clear_cache and os.path.exists(cache):\nshutil.rmtree(cache, True)\nos.makedirs(cache, exist_ok=True)\nopts = {\n\"url\": f\"{url}/{version}/{endpoint}/bulk\",\n\"auth\": requests.auth.HTTPBasicAuth(key, secret),\n\"retries\": retry_limit,\n\"add\": {} if api_args is None else api_args,\n\"are_paths\": text_is_path,\n\"request_cache\": request_cache,\n\"cache\": \"\" if cache_overwrite or isinstance(cache, bool) and not cache else cache,\n\"cache_format\": cache_format,\n\"make_request\": make_request,\n}\nopts[\"add_hash\"] = hashlib.md5(\njson.dumps(\n{**opts[\"add\"], \"url\": opts[\"url\"], \"key\": key, \"secret\": secret},\nseparators=(\",\", \":\"),\n).encode()\n).hexdigest()\nuse_pb = (verbose and progress_bar) or progress_bar\nif parallel and len(bundles) &gt; 1:\nwaiter = Queue()\nqueue = Queue()\nmanager = Process(\ntarget=_queue_manager, args=(queue, waiter, n_texts, len(bundles), use_pb, verbose)\n)\nmanager.start()\nprocs = [Process(target=_process, args=(b, opts, queue)) for b in bundles]\nfor cl in procs:\ncl.start()\nfor cl in procs:\ncl.join()\nres = waiter.get()\nelse:\nif use_pb:\npb = tqdm(total=n_texts, leave=verbose)\nres = [_process(b, opts, pb=pb) for b in bundles]\nif use_pb:\npb.close()\n# finalize\nres = pandas.concat(res, ignore_index=True, sort=False)\nif isinstance(cache, str):\n_update_cache(res, cache, cache_format, verbose, start_time, [e[0] for e in opts[\"add\"]])\nif verbose:\nprint(f\"preparing output ({perf_counter() - start_time:.4f})\")\ndata.set_index(\"id\", inplace=True)\nres.set_index(\"id\", inplace=True)\nif res.shape[0] != n_original:\nres = res.join(data[\"text\"])\ndata_absent = data.loc[list(set(data.index).difference(res.index))]\ndata_absent = data_absent.loc[data_absent[\"text\"].isin(res[\"text\"])]\nif data.size:\nres = res.reset_index()\nres.set_index(\"text\", inplace=True)\ndata_dupes = res.loc[data_absent[\"text\"]]\ndata_dupes[\"id\"] = data_absent.index.to_list()\nres = pandas.concat([res, data_dupes])\nres.reset_index(inplace=True, drop=True)\nres.set_index(\"id\", inplace=True)\nres = res.join(data[\"text\"], how=\"outer\")\nif not return_text:\nres.drop(\"text\", axis=1, inplace=True)\nres = res.reset_index()\nif output is not None:\nif verbose:\nprint(f\"writing results to file: {output} ({perf_counter() - start_time:.4f})\")\nres.to_csv(output, index=False)\ndrops = [\"custom\", \"bin\"]\nif not id_specified:\ndrops.append(\"id\")\nres.drop(\n{*drops}.intersection(res.columns),\naxis=\"columns\",\ninplace=True,\n)\nif frameworks is not None:\nif verbose:\nprint(f\"selecting frameworks ({perf_counter() - start_time:.4f})\")\nif isinstance(frameworks, str) or len(frameworks) == 1:\nif framework_prefix is None:\nframework_prefix = False\nframeworks = [frameworks]\nselect = []\nif id_specified:\nselect.append(\"id\")\nif return_text:\nselect.append(\"text\")\nselect.append(\"text_hash\")\nres = res.filter(regex=f\"^(?:{'|'.join(select + frameworks)})(?:$|\\\\.)\")\nif isinstance(framework_prefix, bool) and not framework_prefix:\nprefix_pattern = re.compile(\"^[^.]+\\\\.\")\nres.columns = [prefix_pattern.sub(\"\", col) for col in res.columns]\nif verbose:\nprint(f\"done ({perf_counter() - start_time:.4f})\")\nreturn res\n</code></pre>"},{"location":"functions/status/","title":"Status","text":"<p>Check the status of the API.</p>"},{"location":"functions/status/#receptiviti.status.status","title":"<code>status(url=os.getenv('RECEPTIVITI_URL', ''), key=os.getenv('RECEPTIVITI_KEY', ''), secret=os.getenv('RECEPTIVITI_SECRET', ''), dotenv=False, verbose=True)</code>","text":"<p>Check the API's status.</p> <p>Ping the Receptiviti API to see if it's available, and if your credentials are valid.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the API.</p> <code>os.getenv('RECEPTIVITI_URL', '')</code> <code>key</code> <code>str</code> <p>Your API key.</p> <code>os.getenv('RECEPTIVITI_KEY', '')</code> <code>secret</code> <code>str</code> <p>Your API secret.</p> <code>os.getenv('RECEPTIVITI_SECRET', '')</code> <code>dotenv</code> <code>bool | str</code> <p>Path to a .env file to read environment variables from, or <code>True</code> to look for a file in the current directory.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If <code>False</code>, will not print status messages.</p> <code>True</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>Response from the API server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; receptiviti.status()\n</code></pre> Source code in <code>src\\receptiviti\\status.py</code> <pre><code>def status(\nurl: str = os.getenv(\"RECEPTIVITI_URL\", \"\"),\nkey: str = os.getenv(\"RECEPTIVITI_KEY\", \"\"),\nsecret: str = os.getenv(\"RECEPTIVITI_SECRET\", \"\"),\ndotenv: Union[bool, str] = False,\nverbose=True,\n) -&gt; requests.Response:\n\"\"\"\n    Check the API's status.\n    Ping the Receptiviti API to see if it's available, and if your credentials are valid.\n    Args:\n      url (str): The URL of the API.\n      key (str): Your API key.\n      secret (str): Your API secret.\n      dotenv (bool | str): Path to a .env file to read environment variables from, or `True`\n        to look for a file in the current directory.\n      verbose (bool): If `False`, will not print status messages.\n    Returns:\n      Response from the API server.\n    Examples:\n        &gt;&gt;&gt; receptiviti.status()\n    \"\"\"\nif dotenv is not None and dotenv:\nreadin_env(\".\" if isinstance(dotenv, bool) else dotenv)\nif url == \"\":\nurl = os.getenv(\"RECEPTIVITI_URL\", \"https://api.receptiviti.com\")\nif key == \"\":\nkey = os.getenv(\"RECEPTIVITI_KEY\", \"\")\nif secret == \"\":\nsecret = os.getenv(\"RECEPTIVITI_SECRET\", \"\")\nurl = (\"https://\" if re.match(\"http\", url, re.I) is None else \"\") + re.sub(\n\"/[Vv]\\\\d(?:/.*)?$|/+$\", \"\", url\n)\nif re.match(\"https?://[^.]+[.:][^.]\", url, re.I) is None:\nraise TypeError(\"`url` does not appear to be valid: \" + url)\nres = requests.get(url + \"/v1/ping\", auth=(key, secret), timeout=9999)\ncontent = res.json() if res.text[:1] == \"{\" else {\"message\": res.text}\nif verbose:\nprint(\"Status: \" + (\"OK\" if res.status_code == 200 else \"ERROR\"))\nprint(\n\"Message: \"\n+ (\nstr(res.status_code)\n+ (\" (\" + str(content[\"code\"]) + \")\" if \"code\" in content else \"\")\n+ \": \"\n+ content[\"pong\" if \"pong\" in content else \"message\"]\n)\n)\nreturn res\n</code></pre>"}]}