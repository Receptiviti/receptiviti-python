{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python package to process text with the Receptiviti API.</p>"},{"location":"#installation","title":"Installation","text":"<p>If needed, download Python from python.org, then install the package with pip:</p> <pre><code>pip install git+https://github.com/miserman/receptiviti-py.git\n</code></pre> <p>And load the package in a python console:</p> <pre><code>import receptiviti\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<pre><code># score a single text\nsingle = receptiviti.request(\"a text to score\")\n# score multiple texts, and write results to a file\nmulti = receptiviti.request([\"first text to score\", \"second text\"], \"filename.csv\")\n# score texts in a single file\nresults = receptiviti.request(\"./path/to/file.csv\", text_column = \"text\")\n</code></pre>"},{"location":"#api-access","title":"API Access","text":"<p>To access the API, you will need to load your key and secret, as found on your dashboard.</p> <p>You can enter these as arguments in each function call, but by default they will be looked for in these environment variables:</p> <pre><code>RECEPTIVITI_KEY=\"32lettersandnumbers\"\nRECEPTIVITI_SECRET=\"56LettersAndNumbers\"\n</code></pre> <p>You can store these in a <code>.env</code> (in the current directory or <code>~/Documents</code>) file permanently:</p> <pre><code># use the `dotenv` argument\nreceptiviti.status(dotenv=True)\n# or load variables in beforehand\nreceptiviti.readin_env()\n</code></pre> <p>Or set them temporarily:</p> <pre><code>import os\nos.environ[\"RECEPTIVITI_KEY\"]=\"32lettersandnumbers\"\nos.environ[\"RECEPTIVITI_SECRET\"]=\"56LettersAndNumbers\"\n</code></pre>"},{"location":"functions/readin_env/","title":"Readin env","text":""},{"location":"functions/readin_env/#receptiviti.readin_env.readin_env","title":"<code>readin_env(path='.', name='.env', overwrite=False)</code>","text":"<p>Set environment variables from a .env file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a .env file, or to a directory containing such a file.</p> <code>'.'</code> <code>name</code> <code>str</code> <p>Name of the file, when <code>path</code> points to a directory.</p> <code>'.env'</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, overwrites existing environment variables with</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>If a file is found, it will add contents to <code>os.environ</code>.</p> Source code in <code>src\\receptiviti\\readin_env.py</code> <pre><code>def readin_env(path=\".\", name=\".env\", overwrite=False) -&gt; None:\n\"\"\"\n    Set environment variables from a .env file.\n    Args:\n      path (str): Path to a .env file, or to a directory containing such a file.\n      By default, this will fall back on `~/Documents`.\n      name (str): Name of the file, when `path` points to a directory.\n      overwrite (bool): If `True`, overwrites existing environment variables with\n      the same name as those in the .env file.\n    Returns:\n      None: If a file is found, it will add contents to `os.environ`.\n    \"\"\"\npath = os.path.expanduser(path)\nenvpath = path if os.path.isfile(path) else path + \"/\" + name\nif os.path.isfile(envpath):\nql = re.compile(\"^['\\\"]|['\\\"\\\\s]+$\")\nwith open(envpath, encoding=\"utf-8\") as file:\nfor line in file:\nentry = line.split(\"=\", 1)\nif len(entry) == 2:\nif overwrite or os.getenv(entry[0]) is None:\nos.environ[entry[0]] = ql.sub(\"\", entry[1])\nelif name != \".Renviron\":\nreadin_env(path, \".Renviron\", overwrite)\nelse:\nif path != os.path.expanduser(\"~/Documents\"):\nreadin_env(\"~/Documents\", name, overwrite)\nreturn\n</code></pre>"},{"location":"functions/request/","title":"Request","text":""},{"location":"functions/request/#receptiviti.request.request","title":"<code>request(text, output=None, id=None, text_column=None, id_column=None, api_args={}, bundle_size=1000, bundle_byte_limit=7500000.0, retry_limit=50, cores=cpu_count() - 2, verbose=False, overwrite=False, dotenv=True, key=os.getenv('RECEPTIVITI_KEY', ''), secret=os.getenv('RECEPTIVITI_SECRET', ''), url=os.getenv('RECEPTIVITI_URL', ''))</code>","text":"<p>Send texts to be scored by the API.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | list | pandas.DataFrame</code> <p>Text to be processed.</p> required <code>output</code> <code>str | None</code> <p>Path to a file to write results to.</p> <code>None</code> <code>id</code> <code>str | list</code> <p>Vector of IDs for each <code>text</code>, or a column name in <code>text</code> containing IDs.</p> <code>None</code> <code>text_column</code> <code>str | None</code> <p>Column name in <code>text</code> containing text.</p> <code>None</code> <code>id_column</code> <code>str | None</code> <p>Column name in <code>text</code> containing ids.</p> <code>None</code> <code>api_args</code> <code>dict</code> <p>Additional arguments to include in the request.</p> <code>{}</code> <code>bundle_size</code> <code>int</code> <p>Maximum number of texts per bundle.</p> <code>1000</code> <code>bundle_byte_limit</code> <code>float</code> <p>Maximum byte size of each bundle.</p> <code>7500000.0</code> <code>retry_limit</code> <code>int</code> <p>Number of times to retry a failed request.</p> <code>50</code> <code>cores</code> <code>int</code> <p>Number of CPU cores to use.</p> <code>cpu_count() - 2</code> <code>verbose</code> <code>bool</code> <p>If <code>False</code>, will not print status messages.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, will overwrite an existing <code>output</code> file.</p> <code>False</code> <code>dotenv</code> <code>bool | str</code> <p>Path to a .env file to read environment variables from. By default, will for a file in the current directory or <code>~/Documents</code>. Passed to <code>readin_env</code> as <code>path</code>.</p> <code>True</code> <code>key</code> <code>str</code> <p>Your API key.</p> <code>os.getenv('RECEPTIVITI_KEY', '')</code> <code>secret</code> <code>str</code> <p>Your API secret.</p> <code>os.getenv('RECEPTIVITI_SECRET', '')</code> <code>url</code> <code>str</code> <p>The URL of the API.</p> <code>os.getenv('RECEPTIVITI_URL', '')</code> <p>Returns:</p> Type Description <code>pandas.DataFrame</code> <p>pandas.DataFrame: results</p> Source code in <code>src\\receptiviti\\request.py</code> <pre><code>def request(\ntext: Union[str, list, pandas.DataFrame],\noutput: Union[str, None] = None,\nid: Union[str, list, None] = None,\ntext_column: Union[str, None] = None,\nid_column: Union[str, None] = None,\napi_args: dict = {},\nbundle_size=1000,\nbundle_byte_limit=75e5,\nretry_limit=50,\ncores=cpu_count() - 2,\nverbose=False,\noverwrite=False,\ndotenv: Union[bool, str] = True,\nkey=os.getenv(\"RECEPTIVITI_KEY\", \"\"),\nsecret=os.getenv(\"RECEPTIVITI_SECRET\", \"\"),\nurl=os.getenv(\"RECEPTIVITI_URL\", \"\"),\n) -&gt; pandas.DataFrame:\n\"\"\"\n    Send texts to be scored by the API.\n    Args:\n      text (str | list | pandas.DataFrame): Text to be processed.\n      output (str | None): Path to a file to write results to.\n      id (str | list): Vector of IDs for each `text`, or a column name in `text` containing IDs.\n      text_column (str | None): Column name in `text` containing text.\n      id_column (str | None): Column name in `text` containing ids.\n      api_args (dict): Additional arguments to include in the request.\n      bundle_size (int): Maximum number of texts per bundle.\n      bundle_byte_limit (float): Maximum byte size of each bundle.\n      retry_limit (int): Number of times to retry a failed request.\n      cores (int): Number of CPU cores to use.\n      verbose (bool): If `False`, will not print status messages.\n      overwrite (bool): If `True`, will overwrite an existing `output` file.\n      dotenv (bool | str): Path to a .env file to read environment variables from. By default,\n        will for a file in the current directory or `~/Documents`. Passed to `readin_env` as `path`.\n      key (str): Your API key.\n      secret (str): Your API secret.\n      url (str): The URL of the API.\n    Returns:\n      pandas.DataFrame: results\n    \"\"\"\nif output is not None and os.path.isfile(output) and not overwrite:\nraise RuntimeError(\"`output` file already exists; use `overwrite=True` to overwrite it\")\nstart_time = perf_counter()\n# resolve credentials and check status\nif dotenv:\nreadin_env(\".\" if isinstance(dotenv, bool) else dotenv)\nif url == \"\":\nurl = os.getenv(\"RECEPTIVITI_URL\", \"https://api.receptiviti.com\")\nurl = (\"https://\" if re.match(\"http\", url, re.I) is None else \"\") + re.sub(\n\"/[Vv]\\\\d(?:/.*)?$|/+$\", \"\", url\n)\nif key == \"\":\nkey = os.getenv(\"RECEPTIVITI_KEY\", \"\")\nif secret == \"\":\nsecret = os.getenv(\"RECEPTIVITI_SECRET\", \"\")\napi_status = status(url, key, secret, dotenv, verbose=False)\nif api_status.status_code != 200:\nraise RuntimeError(f\"API status failed: {api_status.status_code}\")\n# resolve text and id\nif isinstance(text, str) and os.path.isfile(text):\nif verbose:\nprint(f\"reading in texts from a file ({perf_counter() - start_time:.4f})\")\ntext = pandas.read_csv(text)\nif isinstance(text, pandas.DataFrame):\nif id_column is not None:\nif id_column in text:\nid = text[id_column].to_list()\nelse:\nraise IndexError(f\"`id_column` ({id_column}) is not in `text`\")\nif text_column is not None:\nif text_column in text:\ntext = text[text_column].to_list()\nelse:\nraise IndexError(f\"`text_column` ({text_column}) is not in `text`\")\nelse:\nraise RuntimeError(\"`text` is a DataFrame, but no `text_column` is specified\")\nif isinstance(text, str):\ntext = [text]\nn_texts = len(text)\nif id is None:\nid = numpy.arange(1, n_texts + 1)\nelif len(id) != n_texts:\nraise RuntimeError(\"`id` is not the same length as `text`\")\n# prepare bundles\nif verbose:\nprint(f\"preparing text ({perf_counter() - start_time:.4f})\")\ndata = pandas.DataFrame({\"text\": text, \"id\": id})\ndata = data[(~data.duplicated(subset=[\"text\"])) | (data[\"text\"] == \"\") | (data[\"text\"].isna())]\nif not len(data):\nraise RuntimeError(\"no valid texts to process\")\nn_bundles = n_texts / min(1000, max(1, bundle_size))\ngroups = data.groupby(\nnumpy.tile(numpy.arange(n_bundles + 1), n_texts)[:n_texts], group_keys=False\n)\nbundles = []\nfor _, group in groups:\nif sys.getsizeof(group) &gt; bundle_byte_limit:\nstart = current = end = 0\nfor txt in group[\"text\"]:\nsize = sys.getsizeof(txt)\nif size &gt; bundle_byte_limit:\nraise RuntimeError(\n\"one of your texts is over the bundle size\"\n+ f\" limit ({bundle_byte_limit / 1e6} MB)\"\n)\nif (current + size) &gt; bundle_byte_limit:\nbundles.append(group[start:end])\nstart = end = end + 1\ncurrent = size\nelse:\nend += 1\ncurrent += size\nbundles.append(group[start:])\nelse:\nbundles.append(group)\nif verbose:\nprint(\nf\"prepared text in {len(bundles)} {'bundles' if len(bundles) &gt; 1 else 'bundle'}\",\nf\"({perf_counter() - start_time:.4f})\",\n)\n# process bundles\nargs = {\n\"url\": url + \"/v1/framework/bulk\",\n\"auth\": (key, secret),\n\"retries\": retry_limit,\n\"add\": api_args,\n}\nif cores &gt; 1:\nwith Pool(cores) as p:\nres = p.starmap_async(process, [(b, args) for b in bundles]).get()\nelse:\nres = [process(b, args) for b in bundles]\nres = pandas.concat(res, ignore_index=True, sort=False)\n# finalize\nif output is not None:\nres.to_csv(output, index=False)\nif verbose:\nprint(f\"done ({perf_counter() - start_time:.4f})\")\nreturn res\n</code></pre>"},{"location":"functions/status/","title":"Status","text":""},{"location":"functions/status/#receptiviti.status.status","title":"<code>status(url=os.getenv('RECEPTIVITI_URL', ''), key=os.getenv('RECEPTIVITI_KEY', ''), secret=os.getenv('RECEPTIVITI_SECRET', ''), dotenv=False, verbose=True)</code>","text":"<p>Check the API's status.</p> <p>Ping the Receptiviti API to see if it's available, and if your credentials are valid.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the API.</p> <code>os.getenv('RECEPTIVITI_URL', '')</code> <code>key</code> <code>str</code> <p>Your API key.</p> <code>os.getenv('RECEPTIVITI_KEY', '')</code> <code>secret</code> <code>str</code> <p>Your API secret.</p> <code>os.getenv('RECEPTIVITI_SECRET', '')</code> <code>dotenv</code> <code>bool | str</code> <p>Path to a .env file to read environment variables from, or <code>True</code> to look for a file in the current directory.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If <code>False</code>, will not print status messages.</p> <code>True</code> <p>Returns:</p> Type Description <code>requests.Response</code> <p>requests.Response: Response from the API server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; receptiviti.status()\n</code></pre> Source code in <code>src\\receptiviti\\status.py</code> <pre><code>def status(\nurl: str = os.getenv(\"RECEPTIVITI_URL\", \"\"),\nkey: str = os.getenv(\"RECEPTIVITI_KEY\", \"\"),\nsecret: str = os.getenv(\"RECEPTIVITI_SECRET\", \"\"),\ndotenv: Union[bool, str] = False,\nverbose=True,\n) -&gt; requests.Response:\n\"\"\"\n    Check the API's status.\n    Ping the Receptiviti API to see if it's available, and if your credentials are valid.\n    Args:\n      url (str): The URL of the API.\n      key (str): Your API key.\n      secret (str): Your API secret.\n      dotenv (bool | str): Path to a .env file to read environment variables from, or `True`\n        to look for a file in the current directory.\n      verbose (bool): If `False`, will not print status messages.\n    Returns:\n      requests.Response: Response from the API server.\n    Examples:\n        &gt;&gt;&gt; receptiviti.status()\n    \"\"\"\nif dotenv is not None and dotenv:\nreadin_env(\".\" if isinstance(dotenv, bool) else dotenv)\nif url == \"\":\nurl = os.getenv(\"RECEPTIVITI_URL\", \"https://api.receptiviti.com\")\nif key == \"\":\nkey = os.getenv(\"RECEPTIVITI_KEY\", \"\")\nif secret == \"\":\nsecret = os.getenv(\"RECEPTIVITI_SECRET\", \"\")\nurl = (\"https://\" if re.match(\"http\", url, re.I) is None else \"\") + re.sub(\n\"/[Vv]\\\\d(?:/.*)?$|/+$\", \"\", url\n)\nif re.match(\"https?://[^.]+[.:][^.]\", url, re.I) is None:\nraise TypeError(\"`url` does not appear to be valid: \" + url)\nres = requests.get(url + \"/v1/ping\", auth=(key, secret), timeout=9999)\ncontent = res.json() if res.text[:1] == \"{\" else {\"message\": res.text}\nif verbose:\nprint(\"Status: \" + (\"OK\" if res.status_code == 200 else \"ERROR\"))\nprint(\n\"Message: \"\n+ (\nstr(res.status_code)\n+ (\" (\" + str(content[\"code\"]) + \")\" if \"code\" in content else \"\")\n+ \": \"\n+ content[\"pong\" if \"pong\" in content else \"message\"]\n)\n)\nreturn res\n</code></pre>"}]}